/* 
 * Cohesity REST API
 *
 * This API provides operations for interfacing with the Cohesity Cluster. NOTE: To view the documentation on the responses, click 'Model' next to 'Example Value' and keep clicking to expand the hierarchy.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAccessTokensApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Generate an Access Token.
        /// </summary>
        /// <remarks>
        /// Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>AccessToken</returns>
        AccessToken GenerateAccessToken (AccessTokenCredential body);

        /// <summary>
        /// Generate an Access Token.
        /// </summary>
        /// <remarks>
        /// Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>ApiResponse of AccessToken</returns>
        ApiResponse<AccessToken> GenerateAccessTokenWithHttpInfo (AccessTokenCredential body);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Generate an Access Token.
        /// </summary>
        /// <remarks>
        /// Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>Task of AccessToken</returns>
        System.Threading.Tasks.Task<AccessToken> GenerateAccessTokenAsync (AccessTokenCredential body);

        /// <summary>
        /// Generate an Access Token.
        /// </summary>
        /// <remarks>
        /// Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>Task of ApiResponse (AccessToken)</returns>
        System.Threading.Tasks.Task<ApiResponse<AccessToken>> GenerateAccessTokenAsyncWithHttpInfo (AccessTokenCredential body);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class AccessTokensApi : IAccessTokensApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="AccessTokensApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AccessTokensApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AccessTokensApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public AccessTokensApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Generate an Access Token. Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>AccessToken</returns>
        public AccessToken GenerateAccessToken (AccessTokenCredential body)
        {
             ApiResponse<AccessToken> localVarResponse = GenerateAccessTokenWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Generate an Access Token. Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>ApiResponse of AccessToken</returns>
        public ApiResponse< AccessToken > GenerateAccessTokenWithHttpInfo (AccessTokenCredential body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling AccessTokensApi->GenerateAccessToken");

            var localVarPath = "/public/accessTokens";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateAccessToken", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessToken>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessToken) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessToken)));
        }

        /// <summary>
        /// Generate an Access Token. Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>Task of AccessToken</returns>
        public async System.Threading.Tasks.Task<AccessToken> GenerateAccessTokenAsync (AccessTokenCredential body)
        {
             ApiResponse<AccessToken> localVarResponse = await GenerateAccessTokenAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Generate an Access Token. Before making other REST API requests, your REST client must make a &#39;POST /public/accessToken&#39; request with a valid Cohesity username and password. This POST request returns an access token and type in the response that is generated by the Cohesity Cluster. Subsequent requests to other Cohesity REST API operations must specify the returned access token and type by setting &#39;Authorization&#39; in the http header in the following format:  Authorization: token_type access_token  The generated token is valid for 24 hours. If a request is made with an expired token, the &#39;Token expired&#39; error message is returned. Add code to your REST client to check for this error and request another access token before reissuing the request.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to generate access token.</param>
        /// <returns>Task of ApiResponse (AccessToken)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AccessToken>> GenerateAccessTokenAsyncWithHttpInfo (AccessTokenCredential body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling AccessTokensApi->GenerateAccessToken");

            var localVarPath = "/public/accessTokens";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateAccessToken", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessToken>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessToken) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessToken)));
        }

    }
}
