/* 
 * Cohesity REST API
 *
 * This API provides operations for interfacing with the Cohesity Cluster. NOTE: To view the documentation on the responses, click 'Model' next to 'Example Value' and keep clicking to expand the hierarchy.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IActiveDirectoryApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges.
        /// </summary>
        /// <remarks>
        /// After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>List&lt;AddedActiveDirectoryPrincipal&gt;</returns>
        List<AddedActiveDirectoryPrincipal> AddActiveDirectoryPrincipals (List<ActiveDirectoryPrincipalsAddParameters> body = null);

        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges.
        /// </summary>
        /// <remarks>
        /// After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>ApiResponse of List&lt;AddedActiveDirectoryPrincipal&gt;</returns>
        ApiResponse<List<AddedActiveDirectoryPrincipal>> AddActiveDirectoryPrincipalsWithHttpInfo (List<ActiveDirectoryPrincipalsAddParameters> body = null);
        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>ActiveDirectoryEntry</returns>
        ActiveDirectoryEntry CreateActiveDirectoryEntry (ActiveDirectoryEntry body);

        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>ApiResponse of ActiveDirectoryEntry</returns>
        ApiResponse<ActiveDirectoryEntry> CreateActiveDirectoryEntryWithHttpInfo (ActiveDirectoryEntry body);
        /// <summary>
        /// Deletes the join with the Active Directory.
        /// </summary>
        /// <remarks>
        /// Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns></returns>
        void DeleteActiveDirectoryEntry (ActiveDirectoryEntry body);

        /// <summary>
        /// Deletes the join with the Active Directory.
        /// </summary>
        /// <remarks>
        /// Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteActiveDirectoryEntryWithHttpInfo (ActiveDirectoryEntry body);
        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;ActiveDirectoryEntry&gt;</returns>
        List<ActiveDirectoryEntry> GetActiveDirectoryEntry ();

        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;ActiveDirectoryEntry&gt;</returns>
        ApiResponse<List<ActiveDirectoryEntry>> GetActiveDirectoryEntryWithHttpInfo ();
        /// <summary>
        /// Fetches the list centrify zones of an active directory domain.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>List&lt;ListCentrifyZone&gt;</returns>
        List<ListCentrifyZone> ListCentrifyZones (string domainName = null);

        /// <summary>
        /// Fetches the list centrify zones of an active directory domain.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>ApiResponse of List&lt;ListCentrifyZone&gt;</returns>
        ApiResponse<List<ListCentrifyZone>> ListCentrifyZonesWithHttpInfo (string domainName = null);
        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters.
        /// </summary>
        /// <remarks>
        /// Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>List&lt;ActiveDirectoryPrincipal&gt;</returns>
        List<ActiveDirectoryPrincipal> SearchActiveDirectoryPrincipals (string domain = null, string objectClass = null, string search = null, List<string> sids = null);

        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters.
        /// </summary>
        /// <remarks>
        /// Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>ApiResponse of List&lt;ActiveDirectoryPrincipal&gt;</returns>
        ApiResponse<List<ActiveDirectoryPrincipal>> SearchActiveDirectoryPrincipalsWithHttpInfo (string domain = null, string objectClass = null, string search = null, List<string> sids = null);
        /// <summary>
        /// Updates the user id mapping info of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ActiveDirectoryEntry</returns>
        ActiveDirectoryEntry UpdateActiveDirectoryIdMapping (IdMappingInfo body, string name);

        /// <summary>
        /// Updates the user id mapping info of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ApiResponse of ActiveDirectoryEntry</returns>
        ApiResponse<ActiveDirectoryEntry> UpdateActiveDirectoryIdMappingWithHttpInfo (IdMappingInfo body, string name);
        /// <summary>
        /// Updates the machine accounts of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ActiveDirectoryEntry</returns>
        ActiveDirectoryEntry UpdateActiveDirectoryMachineAccounts (UpdateMachineAccountsParams body, string name);

        /// <summary>
        /// Updates the machine accounts of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ApiResponse of ActiveDirectoryEntry</returns>
        ApiResponse<ActiveDirectoryEntry> UpdateActiveDirectoryMachineAccountsWithHttpInfo (UpdateMachineAccountsParams body, string name);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges.
        /// </summary>
        /// <remarks>
        /// After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>Task of List&lt;AddedActiveDirectoryPrincipal&gt;</returns>
        System.Threading.Tasks.Task<List<AddedActiveDirectoryPrincipal>> AddActiveDirectoryPrincipalsAsync (List<ActiveDirectoryPrincipalsAddParameters> body = null);

        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges.
        /// </summary>
        /// <remarks>
        /// After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;AddedActiveDirectoryPrincipal&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<AddedActiveDirectoryPrincipal>>> AddActiveDirectoryPrincipalsAsyncWithHttpInfo (List<ActiveDirectoryPrincipalsAddParameters> body = null);
        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>Task of ActiveDirectoryEntry</returns>
        System.Threading.Tasks.Task<ActiveDirectoryEntry> CreateActiveDirectoryEntryAsync (ActiveDirectoryEntry body);

        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>Task of ApiResponse (ActiveDirectoryEntry)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActiveDirectoryEntry>> CreateActiveDirectoryEntryAsyncWithHttpInfo (ActiveDirectoryEntry body);
        /// <summary>
        /// Deletes the join with the Active Directory.
        /// </summary>
        /// <remarks>
        /// Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteActiveDirectoryEntryAsync (ActiveDirectoryEntry body);

        /// <summary>
        /// Deletes the join with the Active Directory.
        /// </summary>
        /// <remarks>
        /// Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteActiveDirectoryEntryAsyncWithHttpInfo (ActiveDirectoryEntry body);
        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;ActiveDirectoryEntry&gt;</returns>
        System.Threading.Tasks.Task<List<ActiveDirectoryEntry>> GetActiveDirectoryEntryAsync ();

        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined.
        /// </summary>
        /// <remarks>
        /// After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;ActiveDirectoryEntry&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ActiveDirectoryEntry>>> GetActiveDirectoryEntryAsyncWithHttpInfo ();
        /// <summary>
        /// Fetches the list centrify zones of an active directory domain.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>Task of List&lt;ListCentrifyZone&gt;</returns>
        System.Threading.Tasks.Task<List<ListCentrifyZone>> ListCentrifyZonesAsync (string domainName = null);

        /// <summary>
        /// Fetches the list centrify zones of an active directory domain.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ListCentrifyZone&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ListCentrifyZone>>> ListCentrifyZonesAsyncWithHttpInfo (string domainName = null);
        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters.
        /// </summary>
        /// <remarks>
        /// Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>Task of List&lt;ActiveDirectoryPrincipal&gt;</returns>
        System.Threading.Tasks.Task<List<ActiveDirectoryPrincipal>> SearchActiveDirectoryPrincipalsAsync (string domain = null, string objectClass = null, string search = null, List<string> sids = null);

        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters.
        /// </summary>
        /// <remarks>
        /// Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ActiveDirectoryPrincipal&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ActiveDirectoryPrincipal>>> SearchActiveDirectoryPrincipalsAsyncWithHttpInfo (string domain = null, string objectClass = null, string search = null, List<string> sids = null);
        /// <summary>
        /// Updates the user id mapping info of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ActiveDirectoryEntry</returns>
        System.Threading.Tasks.Task<ActiveDirectoryEntry> UpdateActiveDirectoryIdMappingAsync (IdMappingInfo body, string name);

        /// <summary>
        /// Updates the user id mapping info of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ApiResponse (ActiveDirectoryEntry)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActiveDirectoryEntry>> UpdateActiveDirectoryIdMappingAsyncWithHttpInfo (IdMappingInfo body, string name);
        /// <summary>
        /// Updates the machine accounts of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ActiveDirectoryEntry</returns>
        System.Threading.Tasks.Task<ActiveDirectoryEntry> UpdateActiveDirectoryMachineAccountsAsync (UpdateMachineAccountsParams body, string name);

        /// <summary>
        /// Updates the machine accounts of an Active Directory.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ApiResponse (ActiveDirectoryEntry)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActiveDirectoryEntry>> UpdateActiveDirectoryMachineAccountsAsyncWithHttpInfo (UpdateMachineAccountsParams body, string name);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ActiveDirectoryApi : IActiveDirectoryApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ActiveDirectoryApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ActiveDirectoryApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ActiveDirectoryApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ActiveDirectoryApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges. After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>List&lt;AddedActiveDirectoryPrincipal&gt;</returns>
        public List<AddedActiveDirectoryPrincipal> AddActiveDirectoryPrincipals (List<ActiveDirectoryPrincipalsAddParameters> body = null)
        {
             ApiResponse<List<AddedActiveDirectoryPrincipal>> localVarResponse = AddActiveDirectoryPrincipalsWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges. After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>ApiResponse of List&lt;AddedActiveDirectoryPrincipal&gt;</returns>
        public ApiResponse< List<AddedActiveDirectoryPrincipal> > AddActiveDirectoryPrincipalsWithHttpInfo (List<ActiveDirectoryPrincipalsAddParameters> body = null)
        {

            var localVarPath = "/public/activeDirectory/principals";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddActiveDirectoryPrincipals", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<AddedActiveDirectoryPrincipal>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<AddedActiveDirectoryPrincipal>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AddedActiveDirectoryPrincipal>)));
        }

        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges. After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>Task of List&lt;AddedActiveDirectoryPrincipal&gt;</returns>
        public async System.Threading.Tasks.Task<List<AddedActiveDirectoryPrincipal>> AddActiveDirectoryPrincipalsAsync (List<ActiveDirectoryPrincipalsAddParameters> body = null)
        {
             ApiResponse<List<AddedActiveDirectoryPrincipal>> localVarResponse = await AddActiveDirectoryPrincipalsAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges. After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an &#39;management&#39; group is created on the Cohesity Cluster for the Active Directory &#39;management&#39; principal group and is associated with the Cohesity &#39;View&#39; role, all users in the referenced Active Directory &#39;management&#39; principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.  NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to add groups or users to the Cohesity Cluster. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;AddedActiveDirectoryPrincipal&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<AddedActiveDirectoryPrincipal>>> AddActiveDirectoryPrincipalsAsyncWithHttpInfo (List<ActiveDirectoryPrincipalsAddParameters> body = null)
        {

            var localVarPath = "/public/activeDirectory/principals";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddActiveDirectoryPrincipals", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<AddedActiveDirectoryPrincipal>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<AddedActiveDirectoryPrincipal>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AddedActiveDirectoryPrincipal>)));
        }

        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>ActiveDirectoryEntry</returns>
        public ActiveDirectoryEntry CreateActiveDirectoryEntry (ActiveDirectoryEntry body)
        {
             ApiResponse<ActiveDirectoryEntry> localVarResponse = CreateActiveDirectoryEntryWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>ApiResponse of ActiveDirectoryEntry</returns>
        public ApiResponse< ActiveDirectoryEntry > CreateActiveDirectoryEntryWithHttpInfo (ActiveDirectoryEntry body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->CreateActiveDirectoryEntry");

            var localVarPath = "/public/activeDirectory";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateActiveDirectoryEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActiveDirectoryEntry>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ActiveDirectoryEntry) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActiveDirectoryEntry)));
        }

        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>Task of ActiveDirectoryEntry</returns>
        public async System.Threading.Tasks.Task<ActiveDirectoryEntry> CreateActiveDirectoryEntryAsync (ActiveDirectoryEntry body)
        {
             ApiResponse<ActiveDirectoryEntry> localVarResponse = await CreateActiveDirectoryEntryAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Join the Cohesity Cluster to the specified Active Directory. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to join an Active Directory.</param>
        /// <returns>Task of ApiResponse (ActiveDirectoryEntry)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ActiveDirectoryEntry>> CreateActiveDirectoryEntryAsyncWithHttpInfo (ActiveDirectoryEntry body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->CreateActiveDirectoryEntry");

            var localVarPath = "/public/activeDirectory";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateActiveDirectoryEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActiveDirectoryEntry>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ActiveDirectoryEntry) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActiveDirectoryEntry)));
        }

        /// <summary>
        /// Deletes the join with the Active Directory. Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns></returns>
        public void DeleteActiveDirectoryEntry (ActiveDirectoryEntry body)
        {
             DeleteActiveDirectoryEntryWithHttpInfo(body);
        }

        /// <summary>
        /// Deletes the join with the Active Directory. Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteActiveDirectoryEntryWithHttpInfo (ActiveDirectoryEntry body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->DeleteActiveDirectoryEntry");

            var localVarPath = "/public/activeDirectory";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteActiveDirectoryEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Deletes the join with the Active Directory. Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteActiveDirectoryEntryAsync (ActiveDirectoryEntry body)
        {
             await DeleteActiveDirectoryEntryAsyncWithHttpInfo(body);

        }

        /// <summary>
        /// Deletes the join with the Active Directory. Deletes the join of the Cohesity Cluster to the specified Active Directory domain. After the deletion, the Cohesity Cluster no longer has access to the principals on the Active Directory. For example, you can no longer log in to the Cohesity Cluster with a user defined in a principal group of the Active Directory domain.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to delete a join with an Active Directory.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteActiveDirectoryEntryAsyncWithHttpInfo (ActiveDirectoryEntry body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->DeleteActiveDirectoryEntry");

            var localVarPath = "/public/activeDirectory";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteActiveDirectoryEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;ActiveDirectoryEntry&gt;</returns>
        public List<ActiveDirectoryEntry> GetActiveDirectoryEntry ()
        {
             ApiResponse<List<ActiveDirectoryEntry>> localVarResponse = GetActiveDirectoryEntryWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;ActiveDirectoryEntry&gt;</returns>
        public ApiResponse< List<ActiveDirectoryEntry> > GetActiveDirectoryEntryWithHttpInfo ()
        {

            var localVarPath = "/public/activeDirectory";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);



            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetActiveDirectoryEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ActiveDirectoryEntry>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<ActiveDirectoryEntry>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ActiveDirectoryEntry>)));
        }

        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;ActiveDirectoryEntry&gt;</returns>
        public async System.Threading.Tasks.Task<List<ActiveDirectoryEntry>> GetActiveDirectoryEntryAsync ()
        {
             ApiResponse<List<ActiveDirectoryEntry>> localVarResponse = await GetActiveDirectoryEntryAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Lists the Active Directories that the Cohesity Cluster has joined. After a Cohesity Cluster has been joined to an Active Directory domain, the users and groups in the domain can be authenticated on the Cohesity Cluster using their Active Directory credentials.  NOTE: The userName and password fields are not populated by this operation.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;ActiveDirectoryEntry&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ActiveDirectoryEntry>>> GetActiveDirectoryEntryAsyncWithHttpInfo ()
        {

            var localVarPath = "/public/activeDirectory";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);



            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetActiveDirectoryEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ActiveDirectoryEntry>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<ActiveDirectoryEntry>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ActiveDirectoryEntry>)));
        }

        /// <summary>
        /// Fetches the list centrify zones of an active directory domain. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>List&lt;ListCentrifyZone&gt;</returns>
        public List<ListCentrifyZone> ListCentrifyZones (string domainName = null)
        {
             ApiResponse<List<ListCentrifyZone>> localVarResponse = ListCentrifyZonesWithHttpInfo(domainName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Fetches the list centrify zones of an active directory domain. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>ApiResponse of List&lt;ListCentrifyZone&gt;</returns>
        public ApiResponse< List<ListCentrifyZone> > ListCentrifyZonesWithHttpInfo (string domainName = null)
        {

            var localVarPath = "/public/activeDirectory/centrifyZones";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (domainName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "domainName", domainName)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListCentrifyZones", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ListCentrifyZone>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<ListCentrifyZone>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ListCentrifyZone>)));
        }

        /// <summary>
        /// Fetches the list centrify zones of an active directory domain. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>Task of List&lt;ListCentrifyZone&gt;</returns>
        public async System.Threading.Tasks.Task<List<ListCentrifyZone>> ListCentrifyZonesAsync (string domainName = null)
        {
             ApiResponse<List<ListCentrifyZone>> localVarResponse = await ListCentrifyZonesAsyncWithHttpInfo(domainName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Fetches the list centrify zones of an active directory domain. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domainName">Specifies the fully qualified domain name (FQDN) of an Active Directory. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ListCentrifyZone&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ListCentrifyZone>>> ListCentrifyZonesAsyncWithHttpInfo (string domainName = null)
        {

            var localVarPath = "/public/activeDirectory/centrifyZones";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (domainName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "domainName", domainName)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListCentrifyZones", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ListCentrifyZone>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<ListCentrifyZone>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ListCentrifyZone>)));
        }

        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters. Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>List&lt;ActiveDirectoryPrincipal&gt;</returns>
        public List<ActiveDirectoryPrincipal> SearchActiveDirectoryPrincipals (string domain = null, string objectClass = null, string search = null, List<string> sids = null)
        {
             ApiResponse<List<ActiveDirectoryPrincipal>> localVarResponse = SearchActiveDirectoryPrincipalsWithHttpInfo(domain, objectClass, search, sids);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters. Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>ApiResponse of List&lt;ActiveDirectoryPrincipal&gt;</returns>
        public ApiResponse< List<ActiveDirectoryPrincipal> > SearchActiveDirectoryPrincipalsWithHttpInfo (string domain = null, string objectClass = null, string search = null, List<string> sids = null)
        {

            var localVarPath = "/public/activeDirectory/principals";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (domain != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "domain", domain)); // query parameter
            if (objectClass != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "objectClass", objectClass)); // query parameter
            if (search != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "search", search)); // query parameter
            if (sids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("csv", "sids", sids)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchActiveDirectoryPrincipals", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ActiveDirectoryPrincipal>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<ActiveDirectoryPrincipal>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ActiveDirectoryPrincipal>)));
        }

        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters. Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>Task of List&lt;ActiveDirectoryPrincipal&gt;</returns>
        public async System.Threading.Tasks.Task<List<ActiveDirectoryPrincipal>> SearchActiveDirectoryPrincipalsAsync (string domain = null, string objectClass = null, string search = null, List<string> sids = null)
        {
             ApiResponse<List<ActiveDirectoryPrincipal>> localVarResponse = await SearchActiveDirectoryPrincipalsAsyncWithHttpInfo(domain, objectClass, search, sids);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List the user and group principals in the Active Directory that match the filter criteria specified using parameters. Optionally limit the search results by specifying security identifiers (SIDs), an object class (user or group) or a substring. You can specify SIDs or a substring but not both.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched. (optional)</param>
        /// <param name="objectClass">Optionally filter by a principal object class such as &#39;kGroup&#39; or &#39;kUser&#39;. If &#39;kGroup&#39; is specified, only group principals are returned. If &#39;kUser&#39; is specified, only user principals are returned. If not specified, both group and user principals are returned. &#39;kUser&#39; specifies a user object class. &#39;kGroup&#39; specifies a group object class. (optional)</param>
        /// <param name="search">Optionally filter by matching a substring. Only principals in the with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified. (optional)</param>
        /// <param name="sids">Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;search&#39; parameter should not be specified. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ActiveDirectoryPrincipal&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ActiveDirectoryPrincipal>>> SearchActiveDirectoryPrincipalsAsyncWithHttpInfo (string domain = null, string objectClass = null, string search = null, List<string> sids = null)
        {

            var localVarPath = "/public/activeDirectory/principals";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (domain != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "domain", domain)); // query parameter
            if (objectClass != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "objectClass", objectClass)); // query parameter
            if (search != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "search", search)); // query parameter
            if (sids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("csv", "sids", sids)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchActiveDirectoryPrincipals", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ActiveDirectoryPrincipal>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<ActiveDirectoryPrincipal>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ActiveDirectoryPrincipal>)));
        }

        /// <summary>
        /// Updates the user id mapping info of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ActiveDirectoryEntry</returns>
        public ActiveDirectoryEntry UpdateActiveDirectoryIdMapping (IdMappingInfo body, string name)
        {
             ApiResponse<ActiveDirectoryEntry> localVarResponse = UpdateActiveDirectoryIdMappingWithHttpInfo(body, name);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Updates the user id mapping info of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ApiResponse of ActiveDirectoryEntry</returns>
        public ApiResponse< ActiveDirectoryEntry > UpdateActiveDirectoryIdMappingWithHttpInfo (IdMappingInfo body, string name)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->UpdateActiveDirectoryIdMapping");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ActiveDirectoryApi->UpdateActiveDirectoryIdMapping");

            var localVarPath = "/public/activeDirectory/{name}/idMappingInfo";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateActiveDirectoryIdMapping", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActiveDirectoryEntry>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ActiveDirectoryEntry) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActiveDirectoryEntry)));
        }

        /// <summary>
        /// Updates the user id mapping info of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ActiveDirectoryEntry</returns>
        public async System.Threading.Tasks.Task<ActiveDirectoryEntry> UpdateActiveDirectoryIdMappingAsync (IdMappingInfo body, string name)
        {
             ApiResponse<ActiveDirectoryEntry> localVarResponse = await UpdateActiveDirectoryIdMappingAsyncWithHttpInfo(body, name);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Updates the user id mapping info of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update user id mapping of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ApiResponse (ActiveDirectoryEntry)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ActiveDirectoryEntry>> UpdateActiveDirectoryIdMappingAsyncWithHttpInfo (IdMappingInfo body, string name)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->UpdateActiveDirectoryIdMapping");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ActiveDirectoryApi->UpdateActiveDirectoryIdMapping");

            var localVarPath = "/public/activeDirectory/{name}/idMappingInfo";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateActiveDirectoryIdMapping", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActiveDirectoryEntry>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ActiveDirectoryEntry) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActiveDirectoryEntry)));
        }

        /// <summary>
        /// Updates the machine accounts of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ActiveDirectoryEntry</returns>
        public ActiveDirectoryEntry UpdateActiveDirectoryMachineAccounts (UpdateMachineAccountsParams body, string name)
        {
             ApiResponse<ActiveDirectoryEntry> localVarResponse = UpdateActiveDirectoryMachineAccountsWithHttpInfo(body, name);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Updates the machine accounts of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>ApiResponse of ActiveDirectoryEntry</returns>
        public ApiResponse< ActiveDirectoryEntry > UpdateActiveDirectoryMachineAccountsWithHttpInfo (UpdateMachineAccountsParams body, string name)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->UpdateActiveDirectoryMachineAccounts");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ActiveDirectoryApi->UpdateActiveDirectoryMachineAccounts");

            var localVarPath = "/public/activeDirectory/{name}/machineAccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateActiveDirectoryMachineAccounts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActiveDirectoryEntry>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ActiveDirectoryEntry) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActiveDirectoryEntry)));
        }

        /// <summary>
        /// Updates the machine accounts of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ActiveDirectoryEntry</returns>
        public async System.Threading.Tasks.Task<ActiveDirectoryEntry> UpdateActiveDirectoryMachineAccountsAsync (UpdateMachineAccountsParams body, string name)
        {
             ApiResponse<ActiveDirectoryEntry> localVarResponse = await UpdateActiveDirectoryMachineAccountsAsyncWithHttpInfo(body, name);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Updates the machine accounts of an Active Directory. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Request to update machine accounts of an Active Directory.</param>
        /// <param name="name">Specifies the Active Directory Domain Name.</param>
        /// <returns>Task of ApiResponse (ActiveDirectoryEntry)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ActiveDirectoryEntry>> UpdateActiveDirectoryMachineAccountsAsyncWithHttpInfo (UpdateMachineAccountsParams body, string name)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling ActiveDirectoryApi->UpdateActiveDirectoryMachineAccounts");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ActiveDirectoryApi->UpdateActiveDirectoryMachineAccounts");

            var localVarPath = "/public/activeDirectory/{name}/machineAccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateActiveDirectoryMachineAccounts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActiveDirectoryEntry>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ActiveDirectoryEntry) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActiveDirectoryEntry)));
        }

    }
}
